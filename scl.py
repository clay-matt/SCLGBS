# This file was *autogenerated* from the file scl.sage.
from sage.all_cmdline import *   # import sage library
_sage_const_2 = Integer(2); _sage_const_0 = Integer(0)################################

# Matt Clay
# version 121016

################################

from utils import *
from sage.numerical.mip import Sum

################################

def scl(g,m,l,verbose = False):
    # compute the scl of g where g is an element in
    # BS(m,l) = < a,t | t a^m T = a^l >

    if t_exp(g) != _sage_const_0 :
        print 'scl({0}) is not defined as |{1}|_t != 0'.format(g,g)
        return

    # put g into normal form and cyclically reduce
    g_normal = normal_form(g,m,l)
    g_cyclic = cyclic(g_normal)

    if verbose:
        print 'm,l = {0},{1}'.format(m,l)
        print 'g = {0}'.format(g_cyclic)
    # end if verbose

    # build turn graph
    Gamma_g = turn_graph(g_cyclic)
    nv = Gamma_g.graph.order()
    E = dual_edge_basis(Gamma_g)

    if verbose:
        print 'Turn Degrees: {0}'.format(Gamma_g.turn_degree)
        print 'Turn Types: {0}'.format(Gamma_g.turn_type)
        # plot turn graph
        print 'Plotting turn graph...'
        P = Gamma_g.graph.plot(graph_border=True,layout='circular')
        P.show()
        print 'Setting up the linear programming problem...'
    # end if verbose

    # construct cycle list
    X = X_variable_list(Gamma_g,m,l)
    Xi = range(_sage_const_0 ,len(X))

    if verbose:
        print 'X variables = {0}'.format(X)
    # end if verbose
        
    # set up linear programming
    lp = MixedIntegerLinearProgram(solver = 'GLPK')
    lp.set_problem_name('Stable Commutator Length for {0}'.format(g))
    x = lp.new_variable()
    # set objective function
    lp.set_objective(Sum(x[i] for i in Xi))
    # edge duality contraints
    for e in E:
        e_bar = dual_edge(e,nv)
        lp.add_constraint(Sum((X[i].get(e,_sage_const_0 ) - X[i].get(e_bar,_sage_const_0 ))*x[i]
                              for i in Xi) == _sage_const_0 , name = 'Dual Edge {0}'.format(e))
    # normalizing so that 2n(S) = 2
    lp.add_constraint(Sum(dict_nv(X[i],_sage_const_0 )*x[i] for i in Xi) == _sage_const_2 ,
                      name = 'Normalize n(s) = 1')

    if verbose:
        lp.show()
    # end if verbose

    # solve
    ndisks = lp.solve()

    if verbose:
        print 'Linear Programming Solution = {0}'.format(ndisks)
        x_value = lp.get_values(x)
        for c in x_value.keys():
            if x_value[c] != _sage_const_0 :
                print '{0} : {1}'.format(x_value[c],X[c])
    # end if verbose

    scl = (t_len(g_cyclic) - ndisks)/_sage_const_2 

    if verbose:
        print 'scl({0}) = {1}'.format(g,scl)
        return
    # end if verbose
    
    return scl
